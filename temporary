//exc1

void setup() {
  Serial.begin(38400);  // Baud rate 38400, 8N1 by default
}

void loop() {
  Serial.println("Hello");
  delay(500);           // Delay to separate transmissions
}


//calc:
//Baudrate: 38400 bits/s  Tbit= 1/38400 = 26,04us
//Half-bit:  Thalf= Tbit/2 = 13,02us
//Frame = 1 start + 8 data bits + 1stops = 10 bits
//Total frame duration = 10 * 26,04 us = 260,4 us

//scope setup
//      ch1 - D1(tx pin)
//      GND - GND
//      Trigger on falling edge (UART start bit = line goes LOW)
//      Display sclae around 10-20us/div
//      idle line = high start = low -> last 26us
//      half-bit time measurement place cursor at the midle of the start bit measure calues hould be 13 us
//      stop bit = line retuns high for one bit period of 26us
//      compare resaults



//exc2_7E1
#include <avr/io.h>

void uart_init_7E1();
void uart_tx(uint8_t c);

void setup() {
  uart_init_7E1();     // Initialize UART in 7E1 format
}

void loop() {
  uart_tx('A');        // Send character repeatedly
  delay(200);
}

void uart_init_7E1() {
  // Enable double-speed mode (same as Arduino core)
  UCSR0A = (1 << U2X0);

  // Baud rate = 115200 → UBRR ≈ 16 (for double speed)
  UBRR0H = 0;
  UBRR0L = 16;

  // Enable transmitter and receiver
  UCSR0B = (1 << TXEN0) | (1 << RXEN0);

  // Frame format:
  // - 7 data bits → UCSZ01:0 = 10
  // - Even parity → UPM01:0 = 10
  // - 1 stop bit → USBS0 = 0
  UCSR0C =
    (1 << UPM01) |      // Even parity
    (0 << USBS0) |      // 1 stop bit
    (1 << UCSZ01) |     // 7-bit data
    (0 << UCSZ00);
}

void uart_tx(uint8_t c) {
  // Wait until the data register is empty
  while (!(UCSR0A & (1 << UDRE0)));
  UDR0 = c;             // Send byte
}


//scope setup:
//  ch1 - d1(tx pin)
//  gnd - gnd
//  set time base = 2us/div or 5us/div
//  triffer falling edge 
//  you should see idle line = high  start bit = low  then 7 databits,parity bits, and stop bits

//Calc:
//Tbit = 1/115200 = 8,68us
//half-bit time = 4,34 us
//7E1 frame: 1 start + 7 data + 1 parity + 1 stop = 10 bits-> 10*8,68 = 68,8 us

// scope meassure 1 bit width start bit or any bit = 8,7 us
// Full frame length = 87 us ofr 7E1



//exc2_7E2
#include <avr/io.h>

void uart_init_7E2();
void uart_tx(uint8_t c);

void setup() {
  uart_init_7E2();     // Now using 7E2
}

void loop() {
  uart_tx('A');
  delay(200);
}

void uart_init_7E2() {
  UCSR0A = (1 << U2X0);   // double speed
  UBRR0H = 0;
  UBRR0L = 16;            // 115200 baud

  UCSR0B = (1 << TXEN0) | (1 << RXEN0);

  UCSR0C =
    (1 << UPM01) |      // Even parity
    (1 << USBS0) |      // 2 stop bits
    (1 << UCSZ01) |     // 7-bit data
    (0 << UCSZ00);
}

void uart_tx(uint8_t c) {
  while (!(UCSR0A & (1 << UDRE0)));
  UDR0 = c;
}



//exc3_i2c_scanner
#include <Wire.h>

void setup() {
  Wire.begin();
  Serial.begin(9600);
  Serial.println("Scanning...");
}

void loop() {
  for (byte address = 1; address < 127; address++) {
    Wire.beginTransmission(address);
    if (Wire.endTransmission() == 0) {
      Serial.print("Found I2C device at 0x");
      Serial.println(address, HEX);
      delay(1000);
    }
  }
  delay(2000);
}

//exc3_SE04_i2c_reading
#include <Wire.h>

#define SENSOR_ADDR 0x20   // ← replace with your scanner result

void setup() {
  Serial.begin(9600);
  Wire.begin();
}

void loop() {
  // Step 1: Trigger measurement
  Wire.beginTransmission(SENSOR_ADDR);
  Wire.write(0x01);     // command to start measurement
  Wire.endTransmission();

  delay(70);            // wait for measurement

  // Step 2: Request 2 bytes (high + low)
  Wire.requestFrom(SENSOR_ADDR, 2);

  if (Wire.available() == 2) {
    int highByte = Wire.read();
    int lowByte  = Wire.read();
    int distance = (highByte << 8) | lowByte;

    Serial.print("Distance: ");
    Serial.print(distance);
    Serial.println(" cm");
  }

  delay(200);
}


//exc3_if_i2c_does_not_work
#define trigPin 9
#define echoPin 10

void setup() {
  Serial.begin(9600);
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
}

void loop() {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);

  long duration = pulseIn(echoPin, HIGH);
  float distance = duration * 0.0343 / 2;

  Serial.println(distance);
  delay(200);
}



//exc4
//formula: Vfan=(d-4)/(20-4) * 255
// 0 = 0 % ; 255 = 100 %

#include <avr/io.h>
#include <util/delay.h>

#define TRIG_PIN 2   // PD2
#define ECHO_PIN 3   // PD3
#define FAN_PIN 6    // PD6 (OC0A)

// ---------- Ultrasonic distance measurement (bare metal) ----------
uint16_t measure_distance_cm() {
    // Trigger the sensor: 10 µs HIGH pulse
    PORTD &= ~(1 << TRIG_PIN);
    _delay_us(2);
    PORTD |= (1 << TRIG_PIN);
    _delay_us(10);
    PORTD &= ~(1 << TRIG_PIN);

    // Wait for echo to go HIGH
    while (!(PIND & (1 << ECHO_PIN)));

    // Measure high pulse width
    uint32_t count = 0;
    while (PIND & (1 << ECHO_PIN)) {
        _delay_us(1);
        count++;
    }

    // Convert to distance (speed of sound)
    // 58 µs per centimeter (approx)
    return count / 58;
}

// ---------- PWM setup (Timer0 Fast PWM on PD6 / OC0A) ----------
void pwm_init() {
    DDRD |= (1 << FAN_PIN);  // PD6 output

    // Fast PWM, non-inverting mode on OC0A
    TCCR0A = (1 << COM0A1) | (1 << WGM01) | (1 << WGM00);

    // Prescaler 64 → ~1kHz PWM
    TCCR0B = (1 << CS01) | (1 << CS00);

    OCR0A = 0;   // start with fan off
}

// ---------- Set fan speed 0–255 ----------
void fan_set_speed(uint8_t speed) {
    OCR0A = speed;
}

// ---------- Setup ----------
void setup() {
    // ultrasonic pins
    DDRD |= (1 << TRIG_PIN);     // trigger output
    DDRD &= ~(1 << ECHO_PIN);    // echo input

    pwm_init();
}

// ---------- Main loop ----------
void loop() {
    uint16_t distance = measure_distance_cm();

    if (distance <= 4) {
        // full speed
        fan_set_speed(255);
    } 
    else if (distance <= 20) {
        // map 4–20 cm → 0–255
        uint8_t speed = (uint8_t)((distance - 4) * (255.0 / 16.0));
        fan_set_speed(speed);
    } 
    else {
        // off
        fan_set_speed(0);
    }

    _delay_ms(2000);   // wait 2 seconds
}

